<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
Copyright 2013 LoopIndex, This file is part of the Track Changes plugin for CKEditor.

The track changes plugin is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License, version 2, as published by the Free Software Foundation.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU Lesser General Public License along with this program as the file lgpl.txt. If not, see http://www.gnu.org/licenses/lgpl.html.

Written by (David *)Frenkiel - https://github.com/imdfl
*/
(function() {

<span id='LITE'>	/**
</span>	 * @class LITE
	 * @singleton
	 * The LITE namespace
	 */
	var LITE = {
<span id='LITE-Events'>			/**
</span>			 * @class LITE.Events
			 */
		Events : {
<span id='LITE-Events-event-INIT'>			/**
</span>			 * @member LITE.Events
			 * @event INIT
			 * string value: &quot;lite:init&quot;
			 * @param {LITE.LITEPlugin} an instance of a lite object associated with a ckeditor instance
			 */
			INIT : &quot;lite:init&quot;,
<span id='LITE-Events-event-ACCEPT'>			/**
</span>			 * @member LITE.Events
			 * @event ACCEPT
			 * string value: &quot;lite:accept&quot;
			 * @param {Object} An object with the &lt;code&gt;options&lt;/code&gt; passed to the accept method
			 */
			ACCEPT : &quot;lite:accept&quot;,
<span id='LITE-Events-event-REJECT'>			/**
</span>			 * @member LITE.Events
			 * @event REJECT
			 * string value: &quot;lite:reject&quot;
			 * @param {Object} An object with the &lt;code&gt;options&lt;/code&gt; passed to the reject method
			 */
			REJECT : &quot;lite:reject&quot;,
<span id='LITE-Events-event-SHOW_HIDE'>			/**
</span>			 * @member LITE.Events
			 * @event SHOW_HIDE
			 * string value: &quot;lite:showHide&quot;
			 * @param {Object} An object with the field &lt;code&gt;show&lt;/code&gt; indicating the new change tracking show stats
			 */
			SHOW_HIDE : &quot;lite:showHide&quot;,
<span id='LITE-Events-event-TRACKING'>			/**
</span>			 * @member LITE.Events
			 * @event TRACKING
			 * string value: &quot;lite:tracking&quot;
			 * @param {Object} An object with the field &lt;code&gt;tracking&lt;/code&gt; indicating the new tracking status
			 */
			TRACKING : &quot;lite:tracking&quot;
		},
		
		Commands : {
			TOGGLE_TRACKING : &quot;lite.ToggleTracking&quot;,
			TOGGLE_SHOW : &quot;lite.ToggleShow&quot;,
			ACCEPT_ALL : &quot;lite.AcceptAll&quot;,
			REJECT_ALL : &quot;lite.RejectAll&quot;,
			ACCEPT_ONE : &quot;lite.AcceptOne&quot;,
			REJECT_ONE : &quot;lite.RejectOne&quot;,
			TOGGLE_TOOLTIPS: &quot;lite.ToggleTooltips&quot;
		}
	},
	
	tooltipDefaults = {
		show: true,
		path: &quot;js/opentip-adapter.min.js&quot;,
		classPath: &quot;OpentipAdapter&quot;,
		cssPath: &quot;css/opentip.css&quot;,
		delay: 500
	},
	
	defaultTooltipTemplate = &quot;Changed by %u %t&quot;,
	
	_emptyRegex = /^[\s\r\n]*$/, // for getting the clean text
		_cleanRE = [{regex: /[\s]*title=\&quot;[^\&quot;]+\&quot;/g, replace: &quot;&quot; },
		            {regex: /[\s]*data-selected=\&quot;[^\&quot;]+\&quot;/g, replace:&quot;&quot;}
					],
	
	_pluginMap = [];
	
	function _findPluginIndex(editor) {
		for (var i = _pluginMap.length; i--;) {
			var rec = _pluginMap[i];
			if (rec.editor == editor) {
				return i;
			}
		}
		return -1;
	}
	
	function _findPluginRec (editor) {
		var ind = _findPluginIndex(editor);
		return ind &gt;= 0 ? _pluginMap[ind] : null;
	}
	
	function _findPlugin(editor) {
		var rec = _findPluginRec(editor);
		return rec &amp;&amp; rec.plugin;
	}
	
	function addPlugin(editor, plugin) {
		_pluginMap.push({
			plugin: plugin,
			editor : editor
		});
	}

	function padString(s, length, padWith, bSuffix) {
		if (null === s || (typeof(s) == &quot;undefined&quot;)) {
			s = &quot;&quot;;
		}
		else {
			s = String(s);
		}
		padWith = String(padWith);
		var padLength = padWith.length;
		for (var i = s.length; i &lt; length; i += padLength) {
			if (bSuffix) {
				s += padWidth;
			}
			else {
				s = padWith + s;
			}
		}
		return s;
	}
	
	function padNumber(s, length) {
		return padString(s, length, '0');
	}
	
<span id='LITE-Events-method-execIECommand'>	/**
</span>	 * Copied from CKEditor
	 */
	function execIECommand(editor, command ) {
		var doc = editor.document,
			body = doc.getBody(),
			enabled = false,
			onExec = function() {
				enabled = true;
			};

		body.on( command, onExec );

		// IE7: document.execCommand has problem to paste into positioned element.
		( CKEDITOR.env.version &gt; 7 ? doc.$ : doc.$.selection.createRange() )[ 'execCommand' ]( command );

		body.removeListener( command, onExec );

		return enabled;
	}


	function relativeDateFormat(date) {
		var now = new Date();
		var today = now.getDate();
		var month = now.getMonth();
		var year = now.getFullYear();
		
		var t = typeof(date);
		if (t == &quot;string&quot; || t == &quot;number&quot;) {
			date = new Date(date);
		}
		
		var months = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;];
		
		if (today == date.getDate() &amp;&amp; month == date.getMonth() &amp;&amp; year == date.getFullYear()) {
			var minutes = Math.floor((now.getTime() - date.getTime()) / 60000);
			if (minutes &lt; 1) {
				return &quot;now&quot;;
			}
			else if (minutes &lt; 2) {
				return &quot;1 minute ago&quot;;
			}
			else if (minutes &lt; 60) {
				return (minutes + &quot; minutes ago&quot;);
			}
			else {
				var hours = date.getHours();
				var minutes = date.getMinutes();
				return &quot;on &quot; + padNumber(hours, 2) + &quot;:&quot; + padNumber(minutes, 2, &quot;0&quot;);
			}
		} 
		else if (year == date.getFullYear()) {
			return &quot;on &quot; + months[date.getMonth()] + &quot; &quot; + date.getDate();
		}
		else {
			return &quot;on &quot; + months[date.getMonth()] + &quot; &quot; + date.getDate() + &quot;, &quot; + date.getFullYear();
		}
	}	
	
	
<span id='LITE-lite'>	/**
</span>	 * @class LITE.lite
	 * The plugin object created by CKEditor. Since only one plugin is created per web page which may contain multiple instances of CKEditor, this object only handles
	 * the lifecycle of {@link LITE.LITEPlugin} the real plugin object.
	 * 
	 */
	CKEDITOR.plugins.add( 'lite',
	{

	props : {
		deleteTag: 'span',
		insertTag: 'span',
		deleteClass: 'ice-del',
		insertClass: 'ice-ins',
		attributes: {
				changeId: 'data-cid',
				userId: 'data-userid',
				userName: 'data-username',
				changeData: 'data-changedata',
				time: 'data-time'
		},
		stylePrefix: 'ice-cts',
		preserveOnPaste: 'p',
		css: 'css/lite.css'
	},
	
	_scriptsLoaded : null, // not false, which means we're loading
	
<span id='LITE-lite-method-init'>	/**
</span>	 * Called by CKEditor to init the plugin
	 * Creates an instance of a {@link LITE.LITEPlugin} if one is not already associated with the given editor. 
	 * @param ed an instance of CKEditor
	 */
	init: function(ed) {
		var rec = _findPluginRec(ed);
		if (rec) { // should not happen
			return;
		}
		// (CKEDITOR.ELEMENT_MODE_INLINE == ed.elementMode) {
		if (! this._inited) { 
			_ieFix();
			this._inited = true;
		}
		var path = this.path,
			plugin = new LITEPlugin(this.props, path),
			liteConfig = CKEDITOR.tools.extend({}, ed.config.lite || {}),
			ttConfig = liteConfig.tooltips;
		
		if (undefined == ttConfig) {
			ttConfig = true;
		}
			
		if (ttConfig === true) {
			ttConfig = tooltipDefaults;
		}
		liteConfig.tooltips = ttConfig;
		
		addPlugin(ed, plugin);
		
		plugin.init(ed, liteConfig);

	
		ed.on(&quot;destroy&quot;, (function(editor) {
			var ind = _findPluginIndex(editor);
			if (ind &gt;= 0) {
				_pluginMap.splice(ind, 1);
			}
		}).bind(this));
		
		if (this._scriptsLoaded) {
			plugin._onScriptsLoaded();
			return;
		}
		else if (this._scriptsLoaded === false) { // still loading, initial value was null
			return;
		}
		
		this._scriptsLoaded = false;
		var	jQueryLoaded = (typeof(jQuery) == &quot;function&quot;),
			self = this,
			jQueryPath = liteConfig.jQueryPath || &quot;js/jquery.min.js&quot;,
			scripts = (liteConfig.includeType ? liteConfig[&quot;includes_&quot; + liteConfig.includeType] : liteConfig.includes) || [&quot;lite-includes.js&quot;];
		
		scripts = scripts.slice(); // create a copy not referenced by the config
		
		for (var i = 0, len = scripts.length; i &lt; len; ++i) {
			scripts[i] = path + scripts[i]; 
		}
		if (! jQueryLoaded) {
			scripts.splice(0, 0, this.path + jQueryPath);
		}
		if (ttConfig.path) {
			scripts.push(this.path + ttConfig.path);
		}
		
		var load1 = function() {
			if (scripts.length &lt; 1) {
				self._scriptsLoaded = true;
				if (! jQueryLoaded) {
					jQuery.noConflict();
				}
				jQuery.each(_pluginMap, (function(i, rec) {
					rec.plugin._onScriptsLoaded();
				}));
			}
			else {
				var script = scripts.shift();
				CKEDITOR.scriptLoader.load(script, function() {load1();}, self);
			}
		};
		
		load1(scripts);		
	},
	
<span id='LITE-lite-method-findPlugin'>	/**
</span>	 * returns the plugin instance associated with an editor
	 * @param editor
	 * @returns {Object} A LITE plugin instance
	 */
	findPlugin : function(editor) {
		return _findPlugin(editor);
	}
	
});
	
<span id='LITE-LITEPlugin'>	/**
</span>	 * @class LITE.LITEPlugin
	 * The LITEPlugin is created per instance of a CKEditor. This object handles all the events and commands associated with change tracking in a specific editor.
	 */
	LITEPlugin = function(props, path) {
		this.props = {};
		this.path = path;
		for (var key in props) {
			if (props.hasOwnProperty(key)) {
				this.props[key] = props[key];
			}
		}
	};

	LITEPlugin.prototype = {
<span id='LITE-LITEPlugin-method-init'>		/**
</span>		 * Called by CKEditor to init the plugin
		 * @param ed an instance of CKEditor
		 * @param {Object} config a configuration object, not null, ready to be used as a local copy
		 */
		init: function(ed, config) {
			this._editor = ed;
			this._domLoaded =  false;
			this._editor =  null;
			this._tracker =  null;
			this._isVisible =  true; // changes are visible
			this._liteCommandNames =  [];
			this._canAcceptReject =  true; // enable state for accept reject overriding editor readonly
			this._removeBindings = [];

			ed.ui.addToolbarGroup('lite');
			this._setPluginFeatures(ed, this.props);
			this._changeTimeout = null;
			this._boundNotifyChange = this._notifyChange.bind(this);

			this._config = config;
			
			var allow = config.acceptRejectInReadOnly === true;
			var commandsMap = 	[	
				{ command : LITE.Commands.TOGGLE_TRACKING,
					exec : this._onToggleTracking, 
					title: &quot;Toggle Tracking Changes&quot;,
					icon: &quot;track_changes_on_off.png&quot;,
					trackingOnly : false
				},
				{
					command: LITE.Commands.TOGGLE_SHOW, 
					exec: this._onToggleShow, 
					title: &quot;Toggle Tracking Changes&quot;,
					icon: &quot;show_hide.png&quot;,
					readOnly : true
				},
				{
					command:LITE.Commands.ACCEPT_ALL, 
					exec:this._onAcceptAll, 
					title:&quot;Accept all changes&quot;,
					icon:&quot;accept_all.png&quot;,
					readOnly : allow
				},
				{
					command:LITE.Commands.REJECT_ALL,
					exec: this._onRejectAll,
					title: &quot;Reject all changes&quot;, 
					icon:&quot;reject_all.png&quot;,
					readOnly : allow
				},
				{
					command:LITE.Commands.ACCEPT_ONE,
					exec:this._onAcceptOne,
					title:&quot;Accept Change&quot;,
					icon:&quot;accept_one.png&quot;,
					readOnly : allow
				},
				{
					command:LITE.Commands.REJECT_ONE,
					exec:this._onRejectOne,
					title:&quot;Reject Change&quot;,
					icon:&quot;reject_one.png&quot;,
					readOnly : allow
				},
				{
					command:LITE.Commands.TOGGLE_TOOLTIPS,
					exec:this._onToggleTooltips,
					readOnly : true
				}
			];
		
			this._isTracking = config.isTracking !== false;
			this._eventsBounds = false;
		
			ed.on(&quot;contentDom&quot;, (function(dom) {
				this._onDomLoaded(dom);
			}).bind(this));
			ed.on(&quot;dataReady&quot;, (function(evt) {
				this._onAfterSetData(evt);
			}).bind(this));
			var path = this.path;
		
			var commands = config.commands || [LITE.Commands.TOGGLE_TRACKING, LITE.Commands.TOGGLE_SHOW, LITE.Commands.ACCEPT_ALL, LITE.Commands.REJECT_ALL, LITE.Commands.ACCEPT_ONE, LITE.Commands.REJECT_ONE];
		
			var self = this;
			
			function add1(rec) {
				ed.addCommand(rec.command, {
					exec : rec.exec.bind(self),
					readOnly: rec.readOnly || false
				});
		
				if (rec.icon &amp;&amp; rec.title &amp;&amp; commands.indexOf(rec.command) &gt;= 0) { // configuration doens't include this command
					var name = self._commandNameToUIName(rec.command);
					ed.ui.addButton(name, {
						label : rec.title,
						command : rec.command,
						icon : path + &quot;icons/&quot; + rec.icon,
						toolbar: &quot;lite&quot;
					}); 
					if (rec.trackingOnly !== false) {
						self._liteCommandNames.push(rec.command);
					}
					
				}
			}
			
			
			for (var i = 0, len = commandsMap.length; i &lt; len; ++i) {
				add1(commandsMap[i]);
			}
			

			if ( ed.addMenuItems ) {
				ed.addMenuGroup ( 'lite', 50);
				var params = {};
				params[LITE.Commands.ACCEPT_ONE] = {
					label : 'Accept Change',
					command : LITE.Commands.ACCEPT_ONE,
					group : 'lite',
					order : 1,
					icon : path + 'icons/accept_one.png'
				};
				params[LITE.Commands.REJECT_ONE] = {
					label : 'Reject Change',
					command : LITE.Commands.REJECT_ONE,
					group : 'lite',
					order : 2,
					icon : path + 'icons/reject_one.png'
				};

				ed.addMenuItems(params);
			}

			if ( ed.contextMenu ) {
				ed.contextMenu.addListener( (function( element, selection ) {
					 if (element &amp;&amp; this._tracker &amp;&amp; this._tracker.currentChangeNode(element)) {
						 var ret = {};
						 ret[LITE.Commands.ACCEPT_ONE] = CKEDITOR.TRISTATE_OFF;
						 ret[LITE.Commands.REJECT_ONE]= CKEDITOR.TRISTATE_OFF;
						 return ret;
					 }
					 else {
						 return null;
					 }
				}).bind(this) );
			}
		},
		
<span id='LITE-LITEPlugin-method-toggleTracking'>		/**
</span>		 * Change the state of change tracking for the change editor associated with this plugin.
		 * Toggles tracking visibility in accordance with the tracking state. 
		 * @param {Boolean} track if undefined - toggle the state, otherwise set the tracking state to this value, 
		 * @param {Boolean} bNotify if not false, dispatch the TRACKING event
		 */	
		toggleTracking: function(track, bNotify) {
			var tracking = (undefined === track) ? ! this._isTracking : track,
				e = this._editor;
			this._isTracking = tracking;
			this._setCommandsState(this._liteCommandNames, tracking ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
/*			for (var i = this._liteCommandNames.length - 1; i &gt;= 0; --i) {
				var cmd = e.getCommand(this._liteCommandNames[i]);
				if (cmd) {
					if (tracking) {
						cmd.enable();
					}
					else {
						cmd.disable();
					}
				}
			} */
			
			this._updateTrackingState();
			this.toggleShow(tracking, false);

			this._setCommandsState(LITE.Commands.TOGGLE_TRACKING, tracking ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);
			var ui = e.ui.get(this._commandNameToUIName(LITE.Commands.TOGGLE_TRACKING));
			if (ui) {
				this._setButtonTitle(ui, tracking ? 'Stop tracking changes' : 'Start tracking changes');
			}
			if (bNotify !== false) {
				e.fire(LITE.Events.TRACKING, {tracking:tracking});
			}
		},
		
<span id='LITE-LITEPlugin-method-toggleShow'>		/**
</span>		 * Change the visibility of tracked changes for the change editor associated with this plugin
		 * @param show if bool, set the visibility state to this value, otherwise toggle the state
		 * @param bNotify if not false, dispatch the TOGGLE_SHOW event
		 */	
		toggleShow : function(show, bNotify) {
			var vis = (typeof(show) == &quot;undefined&quot;) ? (! this._isVisible) : show;
			this._isVisible = vis;
			if (this._isTracking) {
				this._setCommandsState(LITE.Commands.TOGGLE_SHOW, vis ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);
			}
			this._tracker.setShowChanges(vis &amp;&amp; this._isTracking);
			
			var ui = this._editor.ui.get(this._commandNameToUIName(LITE.Commands.TOGGLE_SHOW));
			if (ui) {
				this._setButtonTitle(ui, vis ? 'Hide tracked changes' : 'Show tracked changes');
			}
			if (bNotify !== false) {
				this._editor.fire(LITE.Events.SHOW_HIDE, {show:vis});
			}
		},
		
<span id='LITE-LITEPlugin-method-isVisible'>		/**
</span>		 * Are tracked changes visible?
		 * @returns {Boolean} true if tracked changes are visible
		 */
		isVisible : function() {
			return this._isVisible;
		},
		
<span id='LITE-LITEPlugin-method-isTracking'>		/**
</span>		 * Are changes tracked?
		 * @returns {Boolean} true if changes are tracked
		 */
		isTracking: function() {
			return this._isTracking;
		},
		
<span id='LITE-LITEPlugin-method-acceptAll'>		/**
</span>		 * Accept all tracked changes
		 */
		acceptAll: function(options) {
			this._tracker.acceptAll(options);
			this._cleanup();
			this._editor.fire(LITE.Events.ACCEPT, {options : options});
		},
		
<span id='LITE-LITEPlugin-method-rejectAll'>		/**
</span>		 * Reject all tracked changes
		 */
		rejectAll: function(options) {
			this._tracker.rejectAll(options);
			this._cleanup();
			this._editor.fire(LITE.Events.REJECT, {options : options});
		},
		
<span id='LITE-LITEPlugin-method-setUserInfo'>		/**
</span>		 * Set the name &amp; id of the current user
		 * @param info an object with the fields name, id
		 */
		setUserInfo: function(info) {
			info = info || {};
			this._config.userId = String(info.id);
			this._config.userName = info.name || &quot;&quot;;
			if (this._tracker) {
				this._tracker.setCurrentUser({ id: this._config.userId, name : this._config.userName });
			}
/*			if (this._editor) {
				var lite = this._editor.config.lite || {};
				this._editor.config.lite = lite;
			}; */
		},
		
<span id='LITE-LITEPlugin-method-countChanges'>		/**
</span>		 * Return the count of pending changes
		 * @param options optional list of user ids whose changes we include or exclude (only one of the two should be provided,
		 * exclude has precdence).
		 */
		countChanges : function(options) {
			return ((this._tracker &amp;&amp; this._tracker.countChanges(options)) || 0);		
		},
		
		enableAcceptReject : function(bEnable) {
			this._canAcceptReject  = !!bEnable;
			this._onIceChange();
		},
		
<span id='LITE-LITEPlugin-method-filterIceElement'>		/**
</span>		 * For the CKEditor content filtering system, not operational yet
		 */
		filterIceElement : function( e ) {
			if (! e) {
				return true;
			}
			try {
				if (e.hasClass(this.props.insertClass) || e.hasClass(this.props.deleteClass)) {
					return false;
				}
			}
			catch (e) {
			}
			return true;
		},
		
		getCleanMarkup: function(text) {
			if (null === text || undefined === text) {
				text = (this._editor &amp;&amp; this._editor.getData())  || &quot;&quot;;
			}
			for (var i = _cleanRE.length - 1; i &gt;= 0; --i) {
				text = text.replace(_cleanRE[i].regex, _cleanRE[i].replace);
			}
			return text;
		},
		
		getCleanText : function() {
			var root = this._getBody();
			if (! root){
				return &quot;&quot;;
			}
			var textFragments = new Array();
			textFragments.push(&quot;&quot;);
			var deleteClass = this._tracker.getDeleteClass();
			this._getCleanText(root, textFragments, deleteClass);
			var str = textFragments.join(&quot;\n&quot;);
			str = str.replace(/&amp;nbsp(;)?/ig, ' ');
			return str;
		},

		_getCleanText : function(e, textFragments, deleteClass) { // assumed never to be called with a text node
			var cls = e.getAttribute(&quot;class&quot;);
			if (cls &amp;&amp; cls.indexOf(deleteClass) &gt;= 0) {
				return;
			}
			
			var isBlock;
			if (isBlock = ((e.nodeName &amp;&amp; e.nodeName.toUpperCase() == &quot;BR&quot;) || (&quot;block&quot; == jQuery(e).css(&quot;display&quot;)))) {
				if (_emptyRegex.test(textFragments[textFragments.length - 1])) {
					textFragments[textFragments.length - 1] = &quot;&quot;;
				}
				else {
					textFragments.push(&quot;&quot;);
				}
			}
			for (var child = e.firstChild; child; child = child.nextSibling) {
				var nodeType = child.nodeType;
				if (3 == nodeType) {
					textFragments[textFragments.length - 1] += String(child.nodeValue);
				}
				else if (1 == nodeType || 9 == nodeType || 11 == nodeType) {
					this._getCleanText(child, textFragments, deleteClass);
				}
			}
			if (isBlock) {
				textFragments.push(&quot;&quot;);
			}
		},
		
		_onDomLoaded : function(dom) {
			this._domLoaded = true;
			this._editor = dom.editor;
			this._onReady();
		},
		
		_onScriptsLoaded : function(completed, failed) {
			this._scriptsLoaded = true;
			this._onReady();
		},
		
		_loadCSS : function(doc) {
			var head = doc.getElementsByTagName(&quot;head&quot;)[0];
			function load(path, id) {
				var style = jQuery(head).find('#' + id);
				if (! style.length) {
					style = doc.createElement(&quot;link&quot;);
					style.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;);
					style.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
					style.setAttribute(&quot;id&quot;, id);
					style.setAttribute(&quot;href&quot;, path);
					head.appendChild(style);
				}
			}
			load(this.path + &quot;css/lite.css&quot;, &quot;__lite__css__&quot;);
			
			if (this._config.tooltips.cssPath) {
				load(this.path + this._config.tooltips.cssPath, &quot;__lite_tt_css__&quot;);
			}
		},
		
		_onReady : function() {
			if (! this._scriptsLoaded || ! this._domLoaded) {
				return;
			}
			// leave some time for initing, seems to help...
			setTimeout(this._afterReady.bind(this), 5);
		},
		
		_getBody : function() {
			try {
				return this._editor.editable().$;
			}
			catch (e) {
				return null;
			}
		},
		
		_afterReady : function() {
			var e = this._editor,
				doc = e.document.$,
				body = this._getBody(),
				config = this._config;
			
			this._loadCSS(doc);
			
			if (! this._eventsBounds) {
				this._eventsBounds = true;
				var paste = this._onPaste.bind(this);
				e.on(&quot;afterCommandExec&quot;, this._onAfterCommand.bind(this));
				e.on(&quot;beforeCommandExec&quot;, this._onBeforeCommand.bind(this));
				if (this._config.handlePaste) {
					e.on(&quot;paste&quot;, paste, null, null, 1);
				}
				e.on(&quot;beforeGetData&quot;, this._onBeforeGetData.bind(this));
				e.on(&quot;insertHtml&quot;, paste, null, null, 1);
				e.on(&quot;insertText&quot;, paste, null, null, 1);
				e.on(&quot;insertElement&quot;, paste, null, null, 1);
				e.on(&quot;mode&quot;, this._onModeChange.bind(this), null, null, 1);
				e.on(&quot;readOnly&quot;, this._onReadOnly.bind(this));
			}
			
			if (this._tracker) {
				if (body != this._tracker.getContentElement()) {
					this._tracker.stopTracking(true);
					jQuery(this._tracker).unbind();
					this._tracker = null;
				}
			}
		
			if (null == this._tracker) {
				var iceprops = {
					element: body,
					handleEvents : true,
					mergeBlocks : true,
					currentUser: {
						id: config.userId || &quot;&quot;,
						name: config.userName || &quot;&quot;
					},
					userStyles: config.userStyles,
					changeTypes: {
						insertType: {tag: this.props.insertTag, alias: this.props.insertClass, action:&quot;Inserted&quot;},
						deleteType: {tag: this.props.deleteTag, alias: this.props.deleteClass, action:&quot;Deleted&quot;}
					},
					hostMethods: {
						getHostRange : this._getHostRange.bind(this),
						makeHostElement: function(node) {
							return new CKEDITOR.dom.element(node);
						},
						setHostRange: this._setHostRange.bind(this),
						hostCopy: this._hostCopy.bind(this)
					},
					tooltips: config.tooltips.show,
					tooltipsDelay: config.tooltips.delay
				};
				if (config.tooltips.classPath) {
					try {
						this._tooltipsHandler = new window[config.tooltips.classPath]();
					}
					catch (e){}
					if (! this._tooltipsHandler) {
						this._logError(&quot;Unable to create tooltip handler&quot;, config.tooltips.classPath);
					}
					else {
						var hideTT = this._hideTooltip.bind(this);
						this._tooltipsHandler.init(config.tooltips);
						iceprops.hostMethods.showTooltip = this._showTooltip.bind(this);
						iceprops.hostMethods.hideTooltip = hideTT;
						iceprops.hostMethods.beforeDelete = iceprops.hostMethods.beforeInsert = hideTT;
						
					}
				}

				jQuery.extend(iceprops, this.props);
				this._tracker = new ice.InlineChangeEditor(iceprops);
				try {
					this._tracker.startTracking();
					this.toggleTracking(this._isTracking, false);
					this._updateTrackingState();
					jQuery(this._tracker).on(&quot;change&quot;, this._onIceChange.bind(this)).on(&quot;textChange&quot;, this._onIceTextChanged.bind(this));
					e.fire(LITE.Events.INIT, {lite: this});
					this._onSelectionChanged(null);
					this._onIceChange(null);
				}
				catch(e) {
					this._logError(&quot;ICE plugin init:&quot;, e);
				}
			}
		},
		
		_onToggleShow : function(event) {
			this.toggleShow();
		},
		
		_onToggleTracking : function(event) {
			this.toggleTracking();
		},
		
		_onRejectAll : function(event)  {
			this.rejectAll();
		},
		
		_onAcceptAll : function(event) {
			this.acceptAll();
		},
		
		_onAcceptOne : function(event) {
			var node = this._tracker.currentChangeNode();
			if (node) {
				this._tracker.acceptChange(node);
				this._cleanup();
				this._editor.fire(LITE.Events.ACCEPT);
				this._onSelectionChanged(null);
			}
		},
		
		_onRejectOne : function(event) {
			var node = this._tracker.currentChangeNode();
			if (node) {
				this._tracker.rejectChange(node);
				this._cleanup();
				this._editor.fire(LITE.Events.REJECT);
				this._onSelectionChanged(null);
			}
		},
		
		_onToggleTooltips: function(event) {
			this._tracker &amp;&amp; this._tracker.toggleTooltips();
		},
		
<span id='LITE-LITEPlugin-method-_cleanup'>		/**
</span>		 * Clean up empty ICE elements
		 * @private
		 */
		_cleanup : function() {
			var body = this._getBody();
			empty = jQuery(body).find(self.insertSelector + ':empty,' + self.deleteSelector + ':empty');
			empty.remove();
			this._onSelectionChanged(null);
		},
		
<span id='LITE-LITEPlugin-method-_setButtonTitle'>		/**
</span>		 * Sets the title of a button
		 * @private
		 * @param button
		 * @param title
		 */
		_setButtonTitle : function(button, title) {
			var e = jQuery('#' + button._.id);
			e.attr('title', title);
		},
		
<span id='LITE-LITEPlugin-method-_onAfterCommand'>		/**
</span>		 * Called after the execution of a CKEDITOR command
		 * @private
		 * @param event
		 */
		_onAfterCommand: function(event) {
			var name = this._tracker &amp;&amp; this._isTracking &amp;&amp; event.data &amp;&amp; event.data.name;
			if (&quot;undo&quot; == name || &quot;redo&quot; == name) {
				this._tracker.reload();
			}
		},
		
		_onBeforeCommand: function(event) {
			var name = this._tracker &amp;&amp; this._isTracking &amp;&amp; event.data &amp;&amp; event.data.name;
			if (&quot;cut&quot; == name) {
			}
		},
		
<span id='LITE-LITEPlugin-method-_onModeChange'>		/**
</span>		 * Called after the mode of the editor (wysiwyg/source) changes
		 * @private
		 * @param evt
		 */
		_onModeChange: function(evt){
			this._updateTrackingState();
			setTimeout(this._onIceChange.bind(this), 0);
		},
		
<span id='LITE-LITEPlugin-method-_onBeforeGetData'>		/**
</span>		 * Callback for the editor's beforeGetData event
		 * Remove tooltips from dom
		 */
		_onBeforeGetData: function(evt) {
			if (this._tooltipsHandler) {
				this._tooltipsHandler.hideAll();
			}
		},
		
<span id='LITE-LITEPlugin-method-_onAfterSetData'>		/**
</span>		 * Callback for the editor's afterSetData event
		 * Remove tooltips from dom
		 */
		_onAfterSetData: function(evt) {
			if (this._tracker &amp;&amp; this._tracker.isTracking()) {
				this._tracker.reload();
			}
		},
		
<span id='LITE-LITEPlugin-method-_onReadOnly'>		/**
</span>		 * Called after the readonly state of the editor changes
		 * @private
		 * @param evt
		 */
		_onReadOnly: function(evt){
			this._updateTrackingState();			
		},
		
<span id='LITE-LITEPlugin-method-_updateTrackingState'>		/**
</span>		 * Recalculates the tracking state according to the tracking flag, editor mode and editor readonly
		 * @private
		 */
		_updateTrackingState: function() {
			if (this._tracker) {
				var track = this._isTracking &amp;&amp; this._editor.mode == &quot;wysiwyg&quot; &amp;&amp; ! this._editor.readOnly;
				this._tracker.toggleChangeTracking(track);
				for (var i = this._removeBindings.length - 1; i &gt;= 0; --i) {
					this._removeBindings[i].removeListener();
				}
				this._removeBindings = [];
				if (track) {
					this._removeBindings.push(this._editor.on(&quot;selectionChange&quot;, this._onSelectionChanged.bind(this)));
				}
			}
		},

<span id='LITE-LITEPlugin-method-_onPaste'>		/**
</span>		 * Paste the content of the clipboard through ICE
		 * @private
		 */
		_onPaste : function(evt){
			if (! this._tracker || ! this._isTracking || ! evt) {
				return true;
			}
			var data = evt.data || {},
				ignore = false,
				toInsert = null,
				node = (evt.name == &quot;insertElement&quot;) &amp;&amp; data.$;
			if (! data) {
				return;
			}
			if (&quot;string&quot; == typeof data) {
				data = {
					dataValue: data,
					type: &quot;text&quot;
				}
			}
			if (node) {
				ignore = node.getAttribute(&quot;data-track-changes-ignore&quot;);
			}
			else if (data.dataValue &amp;&amp; &quot;html&quot; == (data.type || data.mode)) {
				try {
					node = jQuery(data.dataValue);
					ignore = node &amp;&amp; node.attr(&quot;data-track-changes-ignore&quot;);
				}
				catch (e) {}
			}
			
			if (ignore) {
				return true;
			}
			//TODO check if we can just clean datavalue, call insert() and proceed
			if (&quot;string&quot; == typeof data.dataValue) {
				try {
					var doc = this._editor.document.$,
						container = doc.createElement(&quot;div&quot;);
					container.innerHTML = String(data.dataValue);
					container = this._tracker.getCleanDOM(container);
					if (! container.innerHTML) {
						return true;
					}
					toInsert = jQuery.makeArray(container.childNodes);
				}
				catch (e) {
					this._logError(&quot;ice plugin paste:&quot;, e);
				}
			}
			else if (node) {
				toInsert = node;
			}
			else {
				return true;
			}
			if (toInsert) {
				this._beforeInsert();
				this._tracker.insert(toInsert);
				this._afterInsert();
			}
			evt.cancel();
			this._onIceTextChanged();
			return false;
		},
		
<span id='LITE-LITEPlugin-method-_setCommandsState'>		/**
</span>		 * Set the state of multiple commands
		 * @param commands An array of command names or a comma separated string
		 * @private
		 */
		_setCommandsState: function(commands, state) {
			if (typeof(commands) == &quot;string&quot;) {
				commands = commands.split(&quot;,&quot;);
			}
			for (var i = commands.length - 1; i &gt;= 0; --i) {
				var cmd = this._editor.getCommand(commands[i]);
				if (cmd) {
					cmd.setState(state);
				}
			}
		},
		
<span id='LITE-LITEPlugin-method-_onSelectionChanged'>		/**
</span>		 * Handler for selection change events (caret moved or text marked/unmarked)
		 * @param event
		 * @private
		 */
		_onSelectionChanged : function(event) {
			var inChange = this._isTracking &amp;&amp; this._tracker &amp;&amp; this._tracker.isInsideChange();
			var state = inChange &amp;&amp; this._canAcceptReject ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;
			this._setCommandsState([LITE.Commands.ACCEPT_ONE, LITE.Commands.REJECT_ONE], state);
		},
		
<span id='LITE-LITEPlugin-method-_onIceChange'>		/**
</span>		 * called when ice fires a change event
		 * @param e jquery event
		 * @private
		 */
		_onIceChange : function(e) {
			var hasChanges = this._isTracking &amp;&amp; this._tracker &amp;&amp; this._tracker.hasChanges();
			var state = hasChanges &amp;&amp; this._canAcceptReject ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;
			this._setCommandsState([LITE.Commands.ACCEPT_ALL, LITE.Commands.REJECT_ALL], state);
			this._onSelectionChanged();
			if (e) { //otherwise it's just a ui update
				this._triggerChange();
			}
		},
		
<span id='global-method-_onIceTextChanged'>		/**
</span>		 * @ignore
		 * @param e
		 */
		_onIceTextChanged : function(e) {
			this._triggerChange();
		},
		
<span id='global-method-_triggerChange'>		/**
</span>		 * @ignore
		 */
		_triggerChange : function() {
			if (! this._changeTimeout) {
				this._changeTimeout = setTimeout(this._boundNotifyChange, 1);
			}
		},
		
<span id='global-method-_notifyChange'>		/**
</span>		 * @ignore
		 */
		_notifyChange : function() {
			this._changeTimeout = null;
			this._editor.fire('change');
		},
		
<span id='global-method-_commandNameToUIName'>		/**
</span>		 * @ignore
		 * @param command
		 * @returns
		 */
		_commandNameToUIName : function(command) {
			return command.replace(&quot;.&quot;, &quot;_&quot;);
		},
		
<span id='global-method-_setPluginFeatures'>		/**
</span>		 * @ignore
		 * @param editor
		 * @param props
		 */
		
		_setPluginFeatures : function(editor, props) {
			if (! editor || ! editor.filter || ! editor.filter.addFeature) {
				return;
			}
			
			try {
				function makeClasses(tag) {
					var classes = [props.deleteClass,props.insertClass];
					for (var i = 0; i &lt; 10;++i) {
						classes.push(props.stylePrefix + &quot;-&quot; + i);
					}
					return /*tag + */'(' + classes.join(',') + ')';
				}
				
				function makeAttributes(tag) {
		//			allowedContent:'span[data-cid,data-time,data-userdata,data-userid,data-username,title]'
					var attrs = ['title'];
					for (var key in props.attributes) {
						if (props.attributes.hasOwnProperty(key)) {
							var value = props.attributes[key];
							if ((typeof value == &quot;string&quot;) &amp;&amp; value.indexOf(&quot;data-&quot;) == 0) {
								attrs.push(value);
							};
						};
					};
					return /*tag + */'[' + attrs.join(',') + ']';
				}
				
				var features = [];
				
				if (props.insertTag) {
					features.push(makeClasses(props.insertTag));
					features.push(makeAttributes(props.insertTag));
					editor.filter.addFeature({
						name: &quot;lite1&quot;,
						allowedContent: props.insertTag+features.join(&quot;&quot;)
					});
				}
				if (props.deleteTag &amp;&amp; props.deleteTag != props.insertTag) {
					features.push(makeClasses(props.deleteTag));
					features.push(makeAttributes(props.deleteTag));
					editor.filter.addFeature({
						name: &quot;lite2&quot;,
						allowedContent: props.insertTag+features.join(&quot;&quot;)
					});
				}
				
			}
			catch (e){
				this._logError(e);
			}
		},
		
<span id='global-method-_setHostRange'>		/**
</span>		 * @ignore
		 * @param range
		 */
		_setHostRange: function(range) {
			var selection = this._editor &amp;&amp; this._editor.getSelection();
			if (selection) {
				selection.selectRanges([range]);
			}
		},
		
		_hostCopy: function() {
			try {
				if ( CKEDITOR.env.ie ) {
					execIECommand(this._editor, &quot;copy&quot; ); 
				}
				else {
					// Other browsers throw an error if the command is disabled.
					this._editor.document.$.execCommand( &quot;copy&quot;, false, null );
				} 
			}
			catch ( e ) {
				_logError(e);
			}
		},

<span id='global-method-_getHostRange'>		/**
</span>		 * @ignore
		 * @returns {Boolean}
		 */
		_getHostRange: function() {
			var selection = this._editor &amp;&amp; this._editor.getSelection(),
				ranges = selection &amp;&amp; selection.getRanges(),
				range = ranges &amp;&amp; ranges[0];
			return range || null;
		},
		
<span id='global-method-_showTooltip'>		/**
</span>		 * @ignore
		 * @param node
		 * @param change
		 */
		_showTooltip: function(node, change) {
			var config = this._config.tooltips;
			if (config.show &amp;&amp; this._tooltipsHandler) {
				var title = this._makeTooltipTitle(change);
				this._tooltipsHandler.showTooltip(node, title, this._editor.container.$);
			}
		},
		
<span id='global-method-_hideTooltip'>		/**
</span>		 * @ignore
		 * @param node
		 */
		_hideTooltip: function(node) {
			if (this._tooltipsHandler) {
				if (node) {
					this._tooltipsHandler.hideTooltip(node);
				}
				else {
					this._tooltipsHandler.hideAll();
				}
			}
		},
		
<span id='global-method-_beforeInsert'>		/**
</span>		 * Copied from ckeditor
		 * @ignore
		 */
		_beforeInsert: function() {
			this._editor.fire( 'saveSnapshot' );
		},

<span id='global-method-_afterInsert'>		/**
</span>		 * Copied from ckeditor
		 * @ignore
		 */
		_afterInsert: function( ) {
			var editor = this._editor;

			editor.getSelection().scrollIntoView();
/*			setTimeout( function() {
				editor.fire( 'saveSnapshot' );
			}, 0 ); */
		},
<span id='global-method-_logError'>/**
</span> * @ignore
 */
		_logError : function() {
			var t = typeof console;
			if (t != &quot;undefined&quot; &amp;&amp; console.error) {
				var args = Array.prototype.slice.apply(arguments);
				console.error(args.join(' '));
			}
		},
		
<span id='global-method-_makeTooltipTitle'>/**
</span> * @ignore
 * @param change
 * @returns {Boolean}
 */		_makeTooltipTitle: function(change) {
			var title = this._config.tooltipTemplate || defaultTooltipTemplate;
			var time = new Date(change.time);
			title = title.replace(/%t/g, relativeDateFormat(time));
			title = title.replace(/%u/g, change.username);
			title = title.replace(/%dd/g, padNumber(time.getDate(), 2));
			title = title.replace(/%d/g, time.getDate());
			title = title.replace(/%mm/g, padNumber(time.getMonth() + 1, 2));
			title = title.replace(/%m/g, time.getMonth() + 1);
			title = title.replace(/%yy/g, padNumber(time.getYear() - 100, 2));
			title = title.replace(/%y/g, time.getFullYear());
			title = title.replace(/%nn/g, padNumber(time.getMinutes(), 2));
			title = title.replace(/%n/g, time.getMinutes());
			title = title.replace(/%hh/g, padNumber(time.getHours(), 2));
			title = title.replace(/%h/g, time.getHours());

			return title;
		}
		

		
	};
	
	function _ieFix () {
		/* Begin fixes for IE */
			Function.prototype.bind = Function.prototype.bind || function () {
				&quot;use strict&quot;;
				var fn = this, args = Array.prototype.slice.call(arguments),
				object = args.shift();
				return function () {
					return fn.apply(object,
				args.concat(Array.prototype.slice.call(arguments)));
				};
			};

			/* Mozilla fix for MSIE indexOf */
			Array.prototype.indexOf = Array.prototype.indexOf || function (searchElement /*, fromIndex */) {
				&quot;use strict&quot;;
				if (this == null) {
					throw new TypeError();
				}
				var t = Object(this);
				var len = t.length &gt;&gt;&gt; 0;
				if (len === 0) {
					return -1;
				}
				var n = 0;
				if (arguments.length &gt; 1) {
					n = Number(arguments[1]);
					if (n != n) { // shortcut for verifying if it's NaN
						n = 0;
					} else if (n != 0 &amp;&amp; n != Infinity &amp;&amp; n != -Infinity) {
						n = (n &gt; 0 || -1) * Math.floo1r(Math.abs(n));
					}
				}
				if (n &gt;= len) {
					return -1;
				}
				var k = n &gt;= 0 ? n : Math.max(len - Math.abs(n), 0);
				for (; k &lt; len; k++) {
					if (k in t &amp;&amp; t[k] === searchElement) {
						return k;
					}
				}
				return -1;
			};

			Array.prototype.lastIndexOf = Array.prototype.indexOf || function (searchElement) {
				&quot;use strict&quot;;
				if (this == null) {
					throw new TypeError();
				}
				var t = Object(this);
				var len = t.length &gt;&gt;&gt; 0;
				while(--len &gt;= 0) {
					if (len in t &amp;&amp; t[len] === searchElement) {
						return len;
					}
				}
				return -1;
			};
	}
})();</pre>
</body>
</html>
